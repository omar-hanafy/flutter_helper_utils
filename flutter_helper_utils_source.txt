
lib/src/exceptions/parsing_exception.dart
```dart
class ParsingException implements Exception {
  ParsingException({
    required this.error,
    required this.parsingInfo,
    StackTrace? stackTrace,
  }) : stackTrace = stackTrace ?? StackTrace.current;
  factory ParsingException.nullObject({
    required StackTrace stackTrace,
    required String parsingInfo,
  }) {
    return ParsingException(
      error: 'Object Is Null',
      parsingInfo: parsingInfo,
      stackTrace: stackTrace,
    );
  }
  final String parsingInfo;
  final Object? error;
  final StackTrace stackTrace;
  @override
  String toString() {
    return '''
ParsingException {
  parsingInfo: $parsingInfo,
  error: $error,
  stackTrace: $stackTrace',
}
''';
  }
}
```

lib/src/exceptions/range_exception.dart
```dart
class RException implements Exception {
  const RException(this.message);
  RException.steps() : message = 'The range must be more than 0';
  final String? message;
  @override
  String toString() {
    return 'RException: ${message ?? ''}';
  }
}
```
lib/src/helper_methods/pagination_helper.dart
```dart

```

lib/src/helper_methods/global_functions.dart
```dart
import 'package:flutter_helper_utils/flutter_helper_utils.dart';
bool isEqual<T>(T value1, T value2) {
  if (value1 is List && value2 is List) return value1.isEqual(value2);
  if (value1 is Set && value2 is Set) return value1.isEqual(value2);
  if (value1 is Map && value2 is Map) return value1.isEqual(value2);
  return value1 == value2;
}
```
lib/src/extensions/duration.dart
```dart
import 'package:dart_helper_utils/dart_helper_utils.dart';
extension FHUDurationExt on Duration {
DateTime get fromNow => DateTime.now() + this;
DateTime get ago => DateTime.now() - this;
}
```

lib/src/extensions/string_extensions/general_string_extensions.dart
```dart
import 'package:flutter/material.dart';
extension FHUNullSafeStringExtensions on String? {
Size get textSize {
    final textPainter = TextPainter(
      text: TextSpan(text: this),
      maxLines: 1,
    )..layout();
    return textPainter.size;
  }
}
```

lib/src/extensions/collections_extensions.dart
```dart
import 'package:flutter/foundation.dart';
extension FHUNullableListExtensions<E> on List<E>? {
  bool isEqual(List<E>? other) => listEquals(this, other);
}
extension FHUMapNullableExtension<K, V> on Map<K, V>? {
  bool isEqual(Map<K, V>? other) => mapEquals(this, other);
}
extension FHUNullableSetExt<E> on Set<E>? {
  bool isEqual(Set<E>? other) => setEquals(this, other);
}
```
lib/src/extensions/flutter_extensions/media_query_extension.dart
```dart
import 'dart:ui';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
extension FHUMediaQueryExtension on BuildContext {
  MediaQueryData get mq => MediaQuery.of(this);

  MediaQueryData? get nullableMQ => MediaQuery.maybeOf(this);

  Orientation get deviceOrientation => MediaQuery.orientationOf(this);

  NavigationMode get navigationMode => MediaQuery.navigationModeOf(this);
  EdgeInsets get padding => MediaQuery.paddingOf(this);
  Brightness get platformBrightness => MediaQuery.platformBrightnessOf(this);
EdgeInsets get viewInsets => MediaQuery.viewInsetsOf(this);EdgeInsets get viewPadding => MediaQuery.viewPaddingOf(this);
Size get sizePx => MediaQuery.sizeOf(this);
bool get isLandscape => deviceOrientation.isLandscape;
bool get isPortrait => deviceOrientation.isPortrait;
double get widthPx => sizePx.width;
double get heightPx => sizePx.height;
double get shortestSide => sizePx.shortestSide;
double get longestSide => sizePx.longestSide;
double get pixelRatio => MediaQuery.devicePixelRatioOf(this);
TextScaler get textScaler => MediaQuery.textScalerOf(this);

  bool get accessibleNavigation => MediaQuery.accessibleNavigationOf(this);

  bool get boldText => MediaQuery.boldTextOf(this);

  bool get disableAnimations => MediaQuery.disableAnimationsOf(this);

  List<DisplayFeature> get displayFeatures =>
      MediaQuery.displayFeaturesOf(this);

  DeviceGestureSettings get gestureSettings =>
      MediaQuery.gestureSettingsOf(this);

  bool get highContrast => MediaQuery.highContrastOf(this);

  bool get invertColors => MediaQuery.invertColorsOf(this);

  Size? get nullableSize => MediaQuery.maybeSizeOf(this);

  Orientation? get nullableOrientation => MediaQuery.maybeOrientationOf(this);

  double? get nullableDevicePixelRatio =>
      MediaQuery.maybeDevicePixelRatioOf(this);

  TextScaler? get nullableTextScaler => MediaQuery.maybeTextScalerOf(this);

  Brightness? get nullablePlatformBrightness =>
      MediaQuery.maybePlatformBrightnessOf(this);

  EdgeInsets? get nullablePadding => MediaQuery.maybePaddingOf(this);

  EdgeInsets? get nullableViewInsets => MediaQuery.maybeViewInsetsOf(this);

  EdgeInsets get systemGestureInsets => MediaQuery.systemGestureInsetsOf(this);

  EdgeInsets? get nullableSystemGestureInsets =>
      MediaQuery.maybeSystemGestureInsetsOf(this);

  EdgeInsets? get nullableViewPadding => MediaQuery.maybeViewPaddingOf(this);

  bool get alwaysUse24HourFormat => MediaQuery.alwaysUse24HourFormatOf(this);

  bool? get nullableAlwaysUse24HourFormat =>
      MediaQuery.maybeAlwaysUse24HourFormatOf(this);

  bool? get nullableAccessibleNavigation =>
      MediaQuery.maybeAccessibleNavigationOf(this);

  bool? get nullableInvertColors => MediaQuery.maybeInvertColorsOf(this);

  bool? get nullableHighContrast => MediaQuery.maybeHighContrastOf(this);

  bool get onOffSwitchLabels => MediaQuery.onOffSwitchLabelsOf(this);

  bool? get nullableOnOffSwitchLabels =>
      MediaQuery.maybeOnOffSwitchLabelsOf(this);

  bool? get nullableDisableAnimations =>
      MediaQuery.maybeDisableAnimationsOf(this);

  bool? get nullableBoldText => MediaQuery.maybeBoldTextOf(this);

  NavigationMode? get nullableNavigationMode =>
      MediaQuery.maybeNavigationModeOf(this);

  DeviceGestureSettings? get nullableGestureSettings =>
      MediaQuery.maybeGestureSettingsOf(this);

  List<DisplayFeature>? get nullableDisplayFeatures =>
      MediaQuery.maybeDisplayFeaturesOf(this);
}
extension FHUOrientationEx on Orientation {
bool get isLandscape => this == Orientation.landscape;
bool get isPortrait => this == Orientation.portrait;
}
```
lib/src/extensions/flutter_extensions/platform_extension.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
extension FHUPlatformExtension on BuildContext {
  TargetPlatform? get targetPlatform => Theme.of(this).platform;
}
extension FHUPlatformExtensionNullable on BuildContext? {
  TargetPlatform? get targetPlatform =>
      this == null ? null : Theme.of(this!).platform;
  bool get isMobile => targetPlatform.isMobile;
  bool get isIOS => targetPlatform.isIOS;
  bool get isAndroid => targetPlatform.isAndroid;
  bool get isDesktop => targetPlatform.isDesktop;
  bool get isMacOS => targetPlatform.isMacOS;
  bool get isWindows => targetPlatform.isWindows;
  bool get isLinux => targetPlatform.isLinux;
  bool get isApple => targetPlatform.isApple;
  bool get isMobileWeb => targetPlatform.isMobileWeb;
  bool get isIOSWeb => targetPlatform.isIOSWeb;
  bool get isAndroidWeb => targetPlatform.isAndroidWeb;
  bool get isDesktopWeb => targetPlatform.isDesktopWeb;
  bool get isMacOsWeb => targetPlatform.isMacOsWeb;
  bool get isWindowsWeb => targetPlatform.isWindowsWeb;
  bool get isLinuxWeb => targetPlatform.isLinuxWeb;
  bool get isAppleWeb => targetPlatform.isAppleWeb;
}
extension FHUTargetPlatformExtension on TargetPlatform? {
  bool get isMobile =>
      !kIsWeb && (this == TargetPlatform.iOS || this == TargetPlatform.android);
  bool get isIOS => !kIsWeb && this == TargetPlatform.iOS;
  bool get isAndroid => !kIsWeb && this == TargetPlatform.android;
  bool get isDesktop =>
      !kIsWeb &&
      (this == TargetPlatform.linux ||
          this == TargetPlatform.macOS ||
          this == TargetPlatform.windows);
  bool get isMacOS => !kIsWeb && this == TargetPlatform.macOS;
  bool get isWindows => !kIsWeb && this == TargetPlatform.windows;
  bool get isLinux => !kIsWeb && this == TargetPlatform.linux;
  bool get isApple =>
      !kIsWeb && (this == TargetPlatform.macOS || this == TargetPlatform.iOS);
  bool get isMobileWeb =>
      kIsWeb && (this == TargetPlatform.iOS || this == TargetPlatform.android);
  bool get isIOSWeb => kIsWeb && this == TargetPlatform.iOS;
  bool get isAndroidWeb => kIsWeb && this == TargetPlatform.android;
  bool get isDesktopWeb =>
      kIsWeb &&
      (this == TargetPlatform.linux ||
          this == TargetPlatform.macOS ||
          this == TargetPlatform.windows);
  bool get isMacOsWeb => kIsWeb && this == TargetPlatform.macOS;
  bool get isWindowsWeb => kIsWeb && this == TargetPlatform.windows;
  bool get isLinuxWeb => kIsWeb && this == TargetPlatform.linux;
  bool get isAppleWeb =>
      kIsWeb && (this == TargetPlatform.macOS || this == TargetPlatform.iOS);
}
```
lib/src/extensions/flutter_extensions/focus_scope_extensions.dart
```dart
import 'package:flutter/material.dart';
extension FHUFocusScopeExtension on BuildContext {

  FocusScopeNode get focusScope => FocusScope.of(this);
void get unFocus => focusScope.unfocus();

  void get requestFocus => focusScope.requestFocus(FocusNode());
  GestureTapCallback get requestFocusCall =>
      () => focusScope.requestFocus(FocusNode());

bool get hasFocus => focusScope.hasFocus;
bool get hasPrimaryFocus => focusScope.hasPrimaryFocus;
}
```
lib/src/extensions/flutter_extensions/list_widget.dart
```dart
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
extension FHUListExtensions<E> on List<Widget> {
  Widget toRow({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
  }) =>
      Row(
        key: key,
        mainAxisAlignment: mainAxisAlignment,
        mainAxisSize: mainAxisSize,
        crossAxisAlignment: crossAxisAlignment,
        textDirection: textDirection,
        verticalDirection: verticalDirection,
        textBaseline: textBaseline,
        children: this,
      );
  Widget toStack({
    Key? key,
    AlignmentGeometry alignment = AlignmentDirectional.topStart,
    TextDirection? textDirection,
    StackFit fit = StackFit.loose,
    Clip clip = Clip.hardEdge,
  }) =>
      Stack(
        key: key,
        alignment: alignment,
        textDirection: textDirection,
        fit: fit,
        clipBehavior: clip,
        children: this,
      );
  Widget toColumn({
    Key? key,
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,
    MainAxisSize mainAxisSize = MainAxisSize.max,
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,
    TextDirection? textDirection,
    VerticalDirection verticalDirection = VerticalDirection.down,
    TextBaseline? textBaseline,
  }) =>
      Column(
        key: key,
        mainAxisAlignment: mainAxisAlignment,
        mainAxisSize: mainAxisSize,
        crossAxisAlignment: crossAxisAlignment,
        textDirection: textDirection,
        verticalDirection: verticalDirection,
        textBaseline: textBaseline,
        children: this,
      );
  Widget toList({
    Key? key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController? controller,
    bool? primary,
    ScrollPhysics? physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry? padding,
    double? itemExtent,
    Widget? prototypeItem,
    double? cacheExtent,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior =
        ScrollViewKeyboardDismissBehavior.manual,
    String? restorationId,
    Clip clipBehavior = Clip.hardEdge,
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    int? semanticChildCount,
  }) =>
      ListView(
        key: key,
        scrollDirection: scrollDirection,
        reverse: reverse,
        controller: controller,
        primary: primary,
        physics: physics,
        shrinkWrap: shrinkWrap,
        padding: padding,
        itemExtent: itemExtent,
        prototypeItem: prototypeItem,
        cacheExtent: cacheExtent,
        dragStartBehavior: dragStartBehavior,
        keyboardDismissBehavior: keyboardDismissBehavior,
        restorationId: restorationId,
        clipBehavior: clipBehavior,
        addAutomaticKeepAlives: addAutomaticKeepAlives,
        addRepaintBoundaries: addRepaintBoundaries,
        addSemanticIndexes: addSemanticIndexes,
        semanticChildCount: semanticChildCount,
        children: this,
      );
  Widget toListView({
    required NullableIndexedWidgetBuilder itemBuilder,
    Key? key,
    Axis scrollDirection = Axis.vertical,
    bool reverse = false,
    ScrollController? controller,
    bool? primary,
    ScrollPhysics? physics,
    bool shrinkWrap = false,
    EdgeInsetsGeometry? padding,
    double? itemExtent,
    Widget? prototypeItem,
    double? cacheExtent,
    DragStartBehavior dragStartBehavior = DragStartBehavior.start,
    ScrollViewKeyboardDismissBehavior keyboardDismissBehavior =
        ScrollViewKeyboardDismissBehavior.manual,
    String? restorationId,
    Clip clipBehavior = Clip.hardEdge,
    bool addAutomaticKeepAlives = true,
    bool addRepaintBoundaries = true,
    bool addSemanticIndexes = true,
    int? semanticChildCount,
    ChildIndexGetter? findChildIndexCallback,
    int? itemCount,
  }) =>
      ListView.builder(
        key: key,
        scrollDirection: scrollDirection,
        reverse: reverse,
        controller: controller,
        primary: primary,
        physics: physics,
        shrinkWrap: shrinkWrap,
        padding: padding,
        itemExtent: itemExtent,
        prototypeItem: prototypeItem,
        cacheExtent: cacheExtent,
        dragStartBehavior: dragStartBehavior,
        keyboardDismissBehavior: keyboardDismissBehavior,
        restorationId: restorationId,
        clipBehavior: clipBehavior,
        addAutomaticKeepAlives: addAutomaticKeepAlives,
        addRepaintBoundaries: addRepaintBoundaries,
        addSemanticIndexes: addSemanticIndexes,
        semanticChildCount: semanticChildCount,
        findChildIndexCallback: findChildIndexCallback,
        itemCount: itemCount ?? length,
        itemBuilder: itemBuilder,
      );
}
```
lib/src/extensions/flutter_extensions/theme_extension.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/src/extensions/flutter_extensions/flutter_extensions.dart';
extension FHUThemeExtension on BuildContext {
  ThemeData get themeData => Theme.of(this);
  TextTheme get txtTheme => themeData.textTheme;
  Brightness get brightness => themeData.brightness;
  Brightness get sysBrightness => mq.platformBrightness;
  bool get isDark => brightness == Brightness.dark;
  bool get isLight => brightness == Brightness.light;
}
extension FHUThemeModeEx on ThemeMode? {
  Brightness getBrightness(BuildContext context) {
    switch (this) {
      case ThemeMode.light:
        return Brightness.light;
      case ThemeMode.dark:
        return Brightness.dark;
      case ThemeMode.system:
        return context.sysBrightness;
      case null:
        return context.sysBrightness;
    }
  }
  bool get isDark => this == ThemeMode.dark;
  bool get isLight => this == ThemeMode.light;
  bool get isSystem => this == ThemeMode.system;
}
extension FHUBrightnessExtension on Brightness? {
  bool get isDark => this == Brightness.dark;
  bool get isLight => this == Brightness.light;
}
```
lib/src/extensions/flutter_extensions/colors_extension.dart
```dart
import 'package:flutter/material.dart';
extension FHUHexColor on Color {
  String toHex({bool leadingHashSign = true}) => '${leadingHashSign ? '#' : ''}'
        '${red.toRadixString(16).padLeft(2, '0')}'
      '${green.toRadixString(16).padLeft(2, '0')}'
      '${blue.toRadixString(16).padLeft(2, '0')}';
}
extension FHUColorExt on String {
bool get isHexColor =>
      RegExp(r'^#?(?:[0-9a-fA-F]{3,4}){1,2}$').hasMatch(this);
Color? get toColor {
    if (isHexColor) {
      final buffer = StringBuffer();
      if (length == 6 || length == 7) buffer.write('FF');
      buffer.write(replaceFirst('#', ''));
      return Color(int.parse(buffer.toString(), radix: 16));
    }
    return null;
  }
}
```
lib/src/extensions/flutter_extensions/padding.dart
```dart
import 'package:flutter/material.dart';
extension FHUPaddingExtensions on Widget {
  Padding paddingAll(double value, {Key? key}) {
    return Padding(
      key: key,
      padding: EdgeInsets.all(value),
      child: this,
    );
  }
  Padding paddingLTRB(
    double left,
    double top,
    double right,
    double bottom, {
    Key? key,
  }) =>
      Padding(
        key: key,
        padding: EdgeInsets.fromLTRB(left, top, right, bottom),
        child: this,
      );
  Padding paddingSymmetric({
    Key? key,
    double v = 0.0,
    double h = 0.0,
  }) =>
      Padding(
        key: key,
        padding: EdgeInsets.symmetric(
          vertical: v,
          horizontal: h,
        ),
        child: this,
      );
  Padding paddingOnly({
    Key? key,
    double left = 0.0,
    double right = 0.0,
    double top = 0.0,
    double bottom = 0.0,
  }) =>
      Padding(
        key: key,
        padding:
            EdgeInsets.only(left: left, right: right, top: top, bottom: bottom),
        child: this,
      );
}
```
lib/src/extensions/flutter_extensions/scaffold_messenger_extension.dart
```dart
import 'package:flutter/material.dart';
extension FHUScaffoldMessengerExtension on BuildContext {
  ScaffoldMessengerState get scaffoldMessenger => ScaffoldMessenger.of(this);  ScaffoldFeatureController<MaterialBanner, MaterialBannerClosedReason>
      showMaterialBanner(MaterialBanner materialBanner) =>
          scaffoldMessenger.showMaterialBanner(materialBanner);  ScaffoldFeatureController<SnackBar, SnackBarClosedReason> showSnackBar(
    SnackBar snackBar,
  ) =>
      scaffoldMessenger.showSnackBar(snackBar);

  void get hideCurrentMaterialBanner =>
      scaffoldMessenger.hideCurrentMaterialBanner();

  void get hideCurrentSnackBar => scaffoldMessenger.hideCurrentSnackBar();  void get removeCurrentMaterialBanner =>
      scaffoldMessenger.removeCurrentMaterialBanner();  void get removeCurrentSnackBar => scaffoldMessenger.removeCurrentSnackBar();

  void get clearMaterialBanners => scaffoldMessenger.clearMaterialBanners();

  void get clearSnackBars => scaffoldMessenger.clearSnackBars();
}
```
lib/src/extensions/flutter_extensions/align.dart
```dart
import 'package:flutter/material.dart';
extension FHUAlignExtensions on Widget {
  Align alignAtBottomCenter({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.bottomCenter,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtTopLeft({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.topLeft,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtBottomLeft({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.bottomLeft,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtBottomRight({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.bottomRight,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtCenterLeft({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.centerLeft,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtCenter({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtCenterRight({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.centerRight,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtLERP(
    Alignment a,
    Alignment b,
    double t, {
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.lerp(a, b, t)!,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignXY(
    double x,
    double y, {
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment(x, y),
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtTopCenter({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.topCenter,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
  Align alignAtTopRight({
    Key? key,
    double? heightFactor,
    double? widthFactor,
  }) =>
      Align(
        key: key,
        alignment: Alignment.topRight,
        heightFactor: heightFactor,
        widthFactor: widthFactor,
        child: this,
      );
}
```

lib/src/extensions/flutter_extensions/navigation.dart
```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
extension FHUNavigationStateExtensions on State {
Future<T?> navigateTo<T>({required Route<T> route}) =>
      Navigator.push(context, route);
Future<T?> navigatePushReplacement<T>({required Route<T> route}) =>
      Navigator.pushReplacement(context, route);
Future<T?> navigateByRouteName<T>(String routeName, {Object? args}) =>
      Navigator.pushNamed(context, routeName, arguments: args);
}
extension FHUNavigationStatelessExtensions on StatelessWidget {
Future<T?> navigateTo<T>({
    required BuildContext context,
    required Route<T> route,
  }) =>
      Navigator.push(context, route);
Future<T?> navigatePushReplacement<T>({
    required BuildContext context,
    required Route<T> route,
  }) =>
      Navigator.pushReplacement(context, route);
Future<T?> navigateByRouteName<T>({
    required BuildContext context,
    required String routeName,
    Object? args,
  }) =>
      Navigator.pushNamed(context, routeName, arguments: args);
}
extension FHUNavigatorExtension on BuildContext {
  void popPage<T extends Object?>([T? result]) =>
      Navigator.pop<T>(this, result);

void popRoot<T extends Object?>([T? result]) =>
      navigator(rootNavigator: true).pop<T>(result);
  NavigatorState navigator({bool rootNavigator = false}) =>
      Navigator.of(this, rootNavigator: rootNavigator);
bool get canPop => Navigator.canPop(this);
Future<T?> pushPage<T extends Object?>(
    Widget screen, {
    RouteSettings? settings,
    bool maintainState = true,
    bool fullscreenDialog = false,
    bool allowSnapshotting = true,
  }) async =>
      Navigator.of(this).push<T>(
        MaterialPageRoute(
          builder: (_) => screen,
          settings: settings,
          maintainState: maintainState,
          fullscreenDialog: fullscreenDialog,
          allowSnapshotting: allowSnapshotting,
        ),
      );
Future<T?> pReplacement<T extends Object?, TO extends Object?>(
    Widget screen, {
    bool allowSnapshotting = true,
    RouteSettings? settings,
    bool maintainState = true,
    bool fullscreenDialog = false,
  }) async =>
      Navigator.of(this).pushReplacement<T, TO>(
        MaterialPageRoute(
          allowSnapshotting: allowSnapshotting,
          builder: (_) => screen,
          settings: settings,
          maintainState: maintainState,
          fullscreenDialog: fullscreenDialog,
        ),
      );
Future<T?> pAndRemoveUntil<T extends Object?>(
    Widget screen, {
    bool allowSnapshotting = true,
    RouteSettings? settings,
    bool maintainState = true,
    bool fullscreenDialog = false,
    bool routes = false,
  }) async =>
      Navigator.of(this).pushAndRemoveUntil<T>(
        MaterialPageRoute(
          allowSnapshotting: allowSnapshotting,
          builder: (_) => screen,
          settings: settings,
          maintainState: maintainState,
          fullscreenDialog: fullscreenDialog,
        ),
        (Route<dynamic> route) => routes,
      );
Future<T?> pNamedAndRemoveUntil<T extends Object?>(
    String screenName,
    RoutePredicate predicate, {
    bool allowSnapshotting = true,
    Object? arguments,
  }) async =>
      Navigator.of(this).pushNamedAndRemoveUntil<T>(
        screenName,
        (route) => false,
        arguments: arguments,
      );
Future<T?> pNamed<T extends Object?>(
    String screenName, {
    Object? arguments,
  }) async =>
      Navigator.of(this).pushNamed<T>(screenName, arguments: arguments);
Future<T?> pReplacementNamed<T extends Object?, TO extends Object?>(
    String screenName, {
    Object? arguments,
    TO? result,
  }) =>
      Navigator.of(this).pushReplacementNamed<T, TO>(
        screenName,
        arguments: arguments,
        result: result,
      );
void popUntil(String screenName) =>
      Navigator.of(this).popUntil(ModalRoute.withName(screenName));

Future<void> maybePop<T extends Object?>([T? result]) async =>
      Navigator.of(this).maybePop<T>(result);void dismissActivePopup() {
    try {
        final currentRoute = ModalRoute.of(this);
        if ((currentRoute is PopupRoute ||
              currentRoute is DialogRoute ||
              currentRoute is RawDialogRoute ||
              currentRoute is ModalBottomSheetRoute ||
              currentRoute is CupertinoModalPopupRoute) &&
          Navigator.of(this).canPop()) {
            Navigator.pop(this);
            dismissActivePopup();
      }
    } catch (_) {}
  }
}
```

lib/src/value_notifier/extensions/listenable_extensions.dart
```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
extension FHUValueListenableExtension<T> on ValueListenable<T> {
  Widget listenableBuilder(
    Widget Function(T v) builder, {
    Key? key,
  }) {
    return ValueListenableBuilder(
      valueListenable: this,
      key: key,
      builder: (_, v, __) => builder(v),
    );
  }
}
```
lib/src/value_notifier/extensions/notifier_extensions.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/src/value_notifier/notifier_classes/notifier_classes.dart';extension FHUValueNotifierExtension<T extends Object> on T {  ValueNotifier<T> get notifier => ValueNotifier<T>(this);
}extension FHUBoolNotifierEx on bool {
BoolNotifier get notifier => BoolNotifier(this);
}extension FHUNumNotifierEx on num {
NumNotifier get notifier => NumNotifier(this);
}extension FHUDoubleNotifierEx on double {
DoubleNotifier get notifier => DoubleNotifier(this);
}extension FHUIntNotifierEx on int {
IntNotifier get notifier => IntNotifier(this);
}extension FHUDateTimeNotifierEx on DateTime {
DateTimeNotifier get notifier => DateTimeNotifier(this);
}extension FHUStringNotifierEx on String {
StringNotifier get notifier => StringNotifier(this);
}extension FHUColorNotifierEx on Color {
ColorNotifier get notifier => ColorNotifier(this);
}extension FHUUriNotifierEx on Uri {
UriNotifier get notifier => UriNotifier(this);
}extension FHUListNotifierEx<E> on List<E> {
ListNotifier<E> get notifier => ListNotifier(this);
}extension FHUSetNotifierEx<E> on Set<E> {
SetNotifier<E> get notifier => SetNotifier(this);
}extension FHUMapNotifierEx<K, V> on Map<K, V> {
MapNotifier<K, V> get notifier => MapNotifier(this);
}
```
lib/src/value_notifier/extensions/stream_to_notifier.dart
```dart
import 'dart:developer';
import 'package:flutter/foundation.dart';

extension FHUStreamToValueNotifier<T> on Stream<T> {
ValueListenable<T> toValueNotifier(
    T initialValue, {
    void Function(T)? onDone,
    void Function(Object, StackTrace)? onError,
  }) {
    final notifier = ValueNotifier<T>(initialValue);
    listen(
      (value) => notifier.value = value,
      onError: onError ?? _defaultOnError,
      onDone: () => onDone?.call(notifier.value),
    );
    return notifier;
  }
  void _defaultOnError(Object error, StackTrace stackTrace) => log(
        'Error on stream $toString()',
            error: error,
        stackTrace: stackTrace,
      );
}
```

lib/src/value_notifier/extensions/value_notifier_extensions.dart
```dart
import 'dart:async';
import 'package:flutter/foundation.dart';
extension FHUValueNotifierExtensions<T> on ValueNotifier<T> {
T get v => value;
  set v(T newValue) => value = newValue;
}
extension FHUValueListenableExtensions<T> on ValueListenable<T> {
VoidCallback onChange(void Function(T value) action) {
    void listener() => action(value);
    addListener(listener);
    return () => removeListener(listener);
  }

  VoidCallback debounce(Duration duration, void Function(T value) action) {
    Timer? debounceTimer;
    void listener() {
      debounceTimer?.cancel();
      debounceTimer = Timer(duration, () => action(value));
    }
    addListener(listener);
    return () => {
          debounceTimer?.cancel(),
          removeListener(listener),
        };
  }

Stream<T> get stream =>
      Stream.periodic(Duration.zero, (_) => value).distinct();
}
```
lib/src/value_notifier/notifier_classes/list_notifier.dart
```dart

import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';class ListNotifier<E> extends ValueNotifier<List<E>> implements List<E> {
  ListNotifier(super.initial);
factory ListNotifier.generate(int length, E Function(int index) generator,
          {bool growable = true}) =>
      ListNotifier(List.generate(length, generator, growable: growable));
  void refresh() => notifyListeners();

  R _updateOnAction<R>(R Function() action) {
    final result = action();
    refresh();
    return result;
  }
  @override
  List<R> cast<R>() => value.cast();  @override
  E operator [](int index) => value[index];  @override
  void operator []=(int index, E value) {
    _updateOnAction(() => this.value[index] = value);
  }@override
  set first(E value) {
    _updateOnAction(() => this.value.first = value);
  }@override
  set last(E value) {
    _updateOnAction(() => this.value.last = value);
  }
  @override
  int get length => value.length;
@override
  set length(int newLength) {
    _updateOnAction(() => value.length = newLength);
  }
  @override
  void add(E value) {
    _updateOnAction(() => this.value.add(value));
  }
  @override
  void addAll(Iterable<E> iterable) {
    _updateOnAction(() => value.addAll(iterable));
  }
  @override
  Iterable<E> get reversed => value.reversed;

  @override
  void sort([int Function(E a, E b)? compare, bool refresh = true]) {
    _updateOnAction(() => value.sort(compare));
  }
  @override
  void shuffle([Random? random, bool refresh = true]) {
    _updateOnAction(() => value.shuffle(random));
  }
  @override
  int indexOf(E element, [int start = 0]) => value.indexOf(element, start);
  @override
  int indexWhere(bool Function(E element) test, [int start = 0]) =>
      value.indexWhere(test, start);
@override
  int lastIndexWhere(bool Function(E element) test, [int? start]) =>
      value.lastIndexWhere(test, start);  @override
  int lastIndexOf(E element, [int? start]) => value.lastIndexOf(element, start);
  @override
  void clear() {
    _updateOnAction(() => value.clear());
  }

@override
  void insert(int index, E element) {
    _updateOnAction(() => value.insert(index, element));
  }

@override
  void insertAll(int index, Iterable<E> iterable) {
    _updateOnAction(() => value.insertAll(index, iterable));
  }
  @override
  void setAll(int index, Iterable<E> iterable) {
    _updateOnAction(() => value.setAll(index, iterable));
  }
@override
  bool remove(Object? value) {
    return _updateOnAction(() => this.value.remove(value));
  }

@override
  E removeLast() => _updateOnAction(() => value.removeLast());
@override
  E removeAt(int index) => _updateOnAction(() => value.removeAt(index));
  @override
  void removeWhere(bool Function(E element) test) {
    _updateOnAction(() => value.removeWhere(test));
  }
  @override
  void retainWhere(bool Function(E element) test) {
    _updateOnAction(() => value.retainWhere(test));
  }
  @override
  List<E> operator +(List<E> other) => value + other;
  @override
  List<E> sublist(int start, [int? end]) => value.sublist(start, end);

  @override
  Iterable<E> getRange(int start, int end) => value.getRange(start, end);
  @override
  void setRange(int start, int end, Iterable<E> iterable,
      [int skipCount = 0, bool refresh = true]) {
    _updateOnAction(() => value.setRange(start, end, iterable, skipCount));
  }@override
  void removeRange(int start, int end) {
    _updateOnAction(() => value.removeRange(start, end));
  }
@override
  void fillRange(int start, int end, [E? fillValue, bool refresh = true]) {
    _updateOnAction(() => value.fillRange(start, end, fillValue));
  }

  @override
  void replaceRange(
    int start,
    int end,
    Iterable<E> replacements,
  ) {
    _updateOnAction(() => value.replaceRange(start, end, replacements));
  }
@override
  Map<int, E> asMap() => value.asMap();@override
  Iterator<E> get iterator => value.iterator;

  @override
  Iterable<E> followedBy(Iterable<E> other) => value.followedBy(other);
@override
  Iterable<T> map<T>(T Function(E e) toElement) => value.map(toElement);
@override
  Iterable<E> where(bool Function(E element) test) => value.where(test);
@override
  Iterable<T> whereType<T>() => value.whereType();
@override
  Iterable<T> expand<T>(Iterable<T> Function(E element) toElements) =>
      value.expand(toElements);  @override
  bool contains(Object? element) => value.contains(element);

  @override
  void forEach(void Function(E element) action) {
    _updateOnAction(() => value.forEach(action));
  }  @override
  E reduce(E Function(E value, E element) combine) {
    return _updateOnAction(() => value.reduce(combine));
  }  @override
  T fold<T>(
    T initialValue,
    T Function(T previousValue, E element) combine,
  ) {
    return _updateOnAction(() => value.fold(initialValue, combine));
  }

@override
  bool every(bool Function(E element) test) => value.every(test);

@override
  String join([String separator = '']) => value.join();

  @override
  bool any(bool Function(E element) test) => value.any(test);

@override
  Set<E> toSet() => value.toSet();
  @override
  bool get isEmpty => value.isEmpty;
  @override
  bool get isNotEmpty => !isEmpty;  @override
  Iterable<E> take(int count) => value.take(count);
  @override
  Iterable<E> takeWhile(bool Function(E value) test) => value.takeWhile(test);
@override
  Iterable<E> skip(int count) => value.skip(count);
  @override
  Iterable<E> skipWhile(bool Function(E value) test) => value.skipWhile(test);  @override
  E get first => value.first;
@override
  E get last => value.last;

@override
  E get single => value.single;
  @override
  E firstWhere(bool Function(E element) test, {E Function()? orElse}) =>
      value.firstWhere(test, orElse: orElse);

  @override
  E lastWhere(bool Function(E element) test, {E Function()? orElse}) =>
      value.lastWhere(test, orElse: orElse);@override
  E singleWhere(bool Function(E element) test, {E Function()? orElse}) =>
      value.singleWhere(test, orElse: orElse);  @override
  E elementAt(int index) => value.elementAt(index);

  @override
  List<E> toList({bool growable = true}) => value.toList(growable: growable);
  bool isEqual(List<E> other) => value.isEqual(other);
}
```
lib/src/value_notifier/notifier_classes/string_notifier.dart
```dart
import 'package:flutter/material.dart';

class StringNotifier extends ValueNotifier<String> {
  StringNotifier(super.initial);
  @override
  String toString() => value;
  void refresh() => notifyListeners();

  R _updateOnAction<R>(R Function() action) {
    final result = action();
    refresh();
    return result;
  }  String operator [](int index) => value[index];
int codeUnitAt(int index) => value.codeUnitAt(index);

int get length => value.length;  int compareTo(String other) => value.compareTo(other);
  bool endsWith(String other) => value.endsWith(other);
  bool startsWith(Pattern pattern, [int index = 0]) =>
      value.startsWith(pattern, index);int indexOf(Pattern pattern, [int start = 0]) =>
      value.indexOf(pattern, start);
  int lastIndexOf(Pattern pattern, [int? start]) =>
      value.lastIndexOf(pattern, start);
bool get isEmpty => value.isEmpty;
bool get isNotEmpty => value.isNotEmpty;String operator +(String other) => _updateOnAction(() => value + other);
String substring(int start, [int? end, bool refresh = true]) =>
      _updateOnAction(() => value.substring(start, end));
String trim() => _updateOnAction(() => value.trim());
  String trimLeft() => _updateOnAction(() => value.trimLeft());
  String trimRight() => _updateOnAction(() => value.trimRight());

  String operator *(int times) => _updateOnAction(
        () => value * times,
      );

  String padLeft(int width, [String padding = ' ', bool refresh = true]) =>
      _updateOnAction(() => value.padLeft(width, padding));

  String padRight(int width, [String padding = ' ', bool refresh = true]) =>
      _updateOnAction(() => value.padRight(width, padding));
bool contains(Pattern other, [int startIndex = 0]) =>
      value.contains(other, startIndex);
  String replaceFirst(Pattern from, String to,
          [int startIndex = 0, bool refresh = true]) =>
      _updateOnAction(() => value.replaceFirst(from, to, startIndex));  String replaceFirstMapped(Pattern from, String Function(Match match) replace,
          [int startIndex = 0, bool refresh = true]) =>
      _updateOnAction(
          () => value.replaceFirstMapped(from, replace, startIndex));

  String replaceAll(Pattern from, String replace) =>
      _updateOnAction(() => value.replaceAll(from, replace));
String replaceAllMapped(
    Pattern from,
    String Function(Match match) replace,
  ) =>
      _updateOnAction(() => value.replaceAllMapped(from, replace));
  String replaceRange(
    int start,
    int? end,
    String replacement,
  ) =>
      _updateOnAction(() => value.replaceRange(start, end, replacement));
List<String> split(Pattern pattern) =>
      _updateOnAction(() => value.split(pattern));String splitMapJoin(
    Pattern pattern, {
    String Function(Match)? onMatch,
    String Function(String)? onNonMatch,
    bool refresh = true,
  }) =>
      _updateOnAction(() => value.splitMapJoin(pattern,
          onMatch: onMatch, onNonMatch: onNonMatch));
List<int> get codeUnits => value.codeUnits;  Runes get runes => value.runes;
  String toLowerCase() => _updateOnAction(() => value.toLowerCase());
  String toUpperCase() => _updateOnAction(() => value.toUpperCase());
}
```
lib/src/value_notifier/notifier_classes/map_notifier.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';class MapNotifier<K, V> extends ValueNotifier<Map<K, V>> implements Map<K, V> {
  MapNotifier(super.initial);
  void refresh() => notifyListeners();

  R _updateOnAction<R>(R Function() action) {
    final result = action();
    refresh();
    return result;
  }
@override
  Map<RK, RV> cast<RK, RV>() => _updateOnAction(() => value.cast<RK, RV>());
@override
  bool containsValue(Object? value) => this.value.containsValue(value);
@override
  bool containsKey(Object? key) => value.containsKey(key);
  @override
  V? operator [](Object? key) => value[key];

@override
  void operator []=(K key, V value) => this.value[key] = value;
@override
  Iterable<MapEntry<K, V>> get entries => value.entries;

  @override
  Map<K2, V2> map<K2, V2>(
    MapEntry<K2, V2> Function(K key, V value) convert,
  ) =>
      _updateOnAction(() => value.map(convert));
  @override
  void addEntries(Iterable<MapEntry<K, V>> newEntries) =>
      _updateOnAction(() => value.addEntries(newEntries));

@override
  V update(K key, V Function(V value) update,
          {V Function()? ifAbsent, bool refresh = true}) =>
      _updateOnAction(() => value.update(key, update, ifAbsent: ifAbsent));
  @override
  void updateAll(V Function(K key, V value) update) =>
      _updateOnAction(() => value.updateAll(update));
  @override
  void removeWhere(bool Function(K key, V value) test) =>
      _updateOnAction(() => value.removeWhere(test));
@override
  V putIfAbsent(K key, V Function() ifAbsent) =>
      _updateOnAction(() => value.putIfAbsent(key, ifAbsent));

  @override
  void addAll(Map<K, V> other) => _updateOnAction(() => value.addAll(other));

  @override
  V? remove(Object? key) => _updateOnAction(() => value.remove(key));
  @override
  void clear() => _updateOnAction(() => value.clear());@override
  void forEach(void Function(K key, V value) action) =>
      _updateOnAction(() => value.forEach(action));
  @override
  Iterable<K> get keys => value.keys;
  @override
  Iterable<V> get values => value.values;
@override
  int get length => value.length;
@override
  bool get isEmpty => value.isEmpty;
@override
  bool get isNotEmpty => value.isNotEmpty;
  bool isEqual(Map<K, V> other) => value.isEqual(other);
}
```
lib/src/value_notifier/notifier_classes/duration_notifier.dart
```dart
import 'package:flutter/material.dart';class DurationNotifier extends ValueNotifier<Duration> implements Duration {
  DurationNotifier(super.initial);
@override
  Duration operator *(num factor) => value * factor;
@override
  Duration operator +(Duration other) => value + other;
@override
  Duration operator -() => -value;
@override
  Duration operator -(Duration other) => value - other;
@override
  bool operator <(Duration other) => value < other;
@override
  bool operator <=(Duration other) => value <= other;
@override
  bool operator >(Duration other) => value > other;
@override
  bool operator >=(Duration other) => value >= other;
@override
  Duration operator ~/(int quotient) => value ~/ quotient;
@override
  Duration abs() => value.abs();
@override
  int compareTo(Duration other) => value.compareTo(other);
@override
  int get inDays => value.inDays;
@override
  int get inHours => value.inHours;
@override
  int get inMicroseconds => value.inMicroseconds;
@override
  int get inMilliseconds => value.inMilliseconds;
@override
  int get inMinutes => value.inMinutes;
@override
  int get inSeconds => value.inSeconds;
@override
  bool get isNegative => value.isNegative;
}
```
lib/src/value_notifier/notifier_classes/bool_notifier.dart
```dart
import 'package:flutter/cupertino.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';

class BoolNotifier extends ValueNotifier<bool> {
  BoolNotifier(super.initial);
}

extension FHUBoolValueNotifierExtension on ValueNotifier<bool> {
void toggle() => value = !value;
void toggleWithCallback(VoidCallback callback) {
    toggle();
    callback();
  }
Future<void> delayedToggle(Duration delay) async {
    await delay.delayed<void>();
    toggle();
  }
void conditionalToggle({required bool condition}) {
    if (condition) toggle();
  }
void setTrue() => value = true;
void setFalse() => value = false;

  bool operator &(bool other) => value & other;

  bool operator |(bool other) => value | other;

  bool operator ^(bool other) => value ^ other;
}
```
lib/src/value_notifier/notifier_classes/set_notifier.dart
```dart
import 'package:flutter/material.dart';
import 'package:flutter_helper_utils/flutter_helper_utils.dart';class SetNotifier<E> extends ValueNotifier<Set<E>> implements Set<E> {
  SetNotifier(super.initial);
  void refresh() => notifyListeners();

  R _updateOnAction<R>(R Function() action) {
    final result = action();
    refresh();
    return result;
  }
  @override
  Set<R> cast<R>() => _updateOnAction(() => value.cast());

@override
  Iterator<E> get iterator => value.iterator;
  @override
  bool contains(Object? value) =>
      _updateOnAction(() => this.value.contains(value));
  @override
  bool add(E value) => _updateOnAction(() => this.value.add(value));
  @override
  void addAll(Iterable<E> elements) =>
      _updateOnAction(() => value.addAll(elements));
@override
  bool remove(Object? value) => _updateOnAction(() => this.value.remove(value));
@override
  E? lookup(Object? object) => _updateOnAction(() => value.lookup(object));
  @override
  void removeAll(Iterable<Object?> elements) =>
      _updateOnAction(() => value.removeAll(elements));

  @override
  void retainAll(Iterable<Object?> elements) =>
      _updateOnAction(() => value.retainAll(elements));
  @override
  void removeWhere(bool Function(E element) test) =>
      _updateOnAction(() => value.removeWhere(test));
@override
  void retainWhere(bool Function(E element) test) =>
      _updateOnAction(() => value.retainWhere(test));
  @override
  bool containsAll(Iterable<Object?> other) =>
      _updateOnAction(() => value.containsAll(other));
@override
  Set<E> intersection(Set<Object?> other) =>
      _updateOnAction(() => value.intersection(other));

@override
  Set<E> union(Set<E> other) => _updateOnAction(() => value.union(other));

@override
  Set<E> difference(Set<Object?> other) =>
      _updateOnAction(() => value.difference(other));@override
  void clear() => _updateOnAction(() => value.clear());
  @override
  Set<E> toSet() => _updateOnAction(() => value.toSet());

  @override
  Iterable<E> followedBy(Iterable<E> other) =>
      _updateOnAction(() => value.followedBy(other));
@override
  Iterable<T> map<T>(T Function(E e) toElement) =>
      _updateOnAction(() => value.map(toElement));
@override
  Iterable<E> where(bool Function(E element) test) =>
      _updateOnAction(() => value.where(test));
@override
  Iterable<T> whereType<T>() => _updateOnAction(() => value.whereType<T>());
@override
  Iterable<T> expand<T>(
    Iterable<T> Function(E element) toElements,
  ) =>
      _updateOnAction(() => value.expand(toElements));  @override
  void forEach(void Function(E element) action) =>
      _updateOnAction(() => value.forEach(action));
  @override
  E reduce(E Function(E value, E element) combine) =>
      _updateOnAction(() => value.reduce(combine));  @override
  T fold<T>(
    T initialValue,
    T Function(T previousValue, E element) combine,
  ) =>
      _updateOnAction(() => value.fold<T>(initialValue, combine));  @override
  bool every(bool Function(E element) test) =>
      _updateOnAction(() => value.every(test));

@override
  String join([String separator = '']) =>
      _updateOnAction(() => value.join(separator));

@override
  bool any(bool Function(E element) test) =>
      _updateOnAction(() => value.any(test));

  @override
  List<E> toList({bool growable = true, bool refresh = true}) =>
      _updateOnAction(() => value.toList(growable: growable));
  @override
  int get length => value.length;
  @override
  bool get isEmpty => value.isEmpty;
  @override
  bool get isNotEmpty => value.isNotEmpty;
  @override
  Iterable<E> take(int count) => _updateOnAction(() => value.take(count));  @override
  Iterable<E> takeWhile(bool Function(E value) test) =>
      _updateOnAction(() => value.takeWhile(test));  @override
  Iterable<E> skip(int count) => _updateOnAction(() => value.skip(count));

@override
  Iterable<E> skipWhile(bool Function(E value) test) =>
      _updateOnAction(() => value.skipWhile(test));
  @override
  E get first => value.first;
  @override
  E get last => value.last;
  @override
  E get single => value.single;
  @override
  E firstWhere(bool Function(E element) test,
          {E Function()? orElse, bool refresh = true}) =>
      _updateOnAction(() => value.firstWhere(test, orElse: orElse));

  @override
  E lastWhere(bool Function(E element) test,
          {E Function()? orElse, bool refresh = true}) =>
      _updateOnAction(() => value.lastWhere(test, orElse: orElse));@override
  E singleWhere(bool Function(E element) test,
          {E Function()? orElse, bool refresh = true}) =>
      _updateOnAction(() => value.singleWhere(test, orElse: orElse));  @override
  E elementAt(int index) => _updateOnAction(() => value.elementAt(index));
  bool isEqual(Set<E> other) => value.isEqual(other);
}
```
lib/src/value_notifier/notifier_classes/num_notifier.dart
```dart
import 'package:flutter/material.dart';

class NumNotifier extends ValueNotifier<num> {
  NumNotifier(super.initial);
}
extension FHUNumericValueNotifierExtension on ValueNotifier<num> {

int compareTo(num other) => value.compareTo(other);  num operator +(num other) => value + other;  num operator -(num other) => value - other;  num operator *(num other) => value * other;  num operator %(num other) => value % other;
double operator /(num other) => value / other;  int operator ~/(num other) => value ~/ other;  num operator -() => -value;
num remainder(num other) => value.remainder(other);  bool operator <(num other) => value < other;  bool operator <=(num other) => value <= other;  bool operator >(num other) => value > other;  bool operator >=(num other) => value >= other;
  bool get isNaN => value.isNaN;  bool get isNegative => value.isNegative;  bool get isInfinite => value.isInfinite;bool get isFinite => value.isFinite;
  num abs() => value.abs();num get sign => value.sign;
  int round() => value.round();
int floor() => value.floor();
int ceil() => value.ceil();
int truncate() => value.truncate();
double roundToDouble() => value.roundToDouble();double floorToDouble() => value.floorToDouble();double ceilToDouble() => value.ceilToDouble();
double truncateToDouble() => value.truncateToDouble();num clamp(num lowerLimit, num upperLimit) =>
      value.clamp(lowerLimit, upperLimit);

  int toInt() => value.toInt();

double toDouble() => value.toDouble();String toStringAsFixed(int fractionDigits) =>
      value.toStringAsFixed(fractionDigits);
String toStringAsExponential([int? fractionDigits]) =>
      value.toStringAsExponential(fractionDigits);
String toStringAsPrecision(int precision) =>
      value.toStringAsPrecision(precision);
void increment([num step = 1]) => value += step;
void reset() => value = 0;
void decrement([num step = 1]) => value -= step;
void multiply(num factor) => value *= factor;
void divide(num divisor) {
    if (divisor != 0) value /= divisor;
  }
void modulo(num divisor) {
    if (divisor != 0) value %= divisor;
  }
void negate() => value = -value;
void min(num other) => value = value < other ? value : other;
void max(num other) => value = value > other ? value : other;
}
```

lib/src/value_notifier/notifier_classes/color_notifier.dart
```dart
import 'package:flutter/cupertino.dart';

class ColorNotifier extends ValueNotifier<Color> {
  ColorNotifier(super.initial);
}
extension FHUColorValueNotifierExtension on ValueNotifier<Color> {
int get alpha => value.alpha;

double get opacity => value.opacity;
int get red => value.red;
int get green => value.green;
int get blue => value.blue;

Color withAlpha(int a) => value.withAlpha(a);

Color withOpacity(double opacity) => value.withOpacity(opacity);

Color withRed(int r) => value.withRed(r);

Color withGreen(int g) => value.withGreen(g);

Color withBlue(int b) => value.withBlue(b);  double computeLuminance() => value.computeLuminance();
}
```
lib/src/value_notifier/notifier_classes/uri_notifier.dart
```dart
import 'package:flutter/material.dart';class UriNotifier extends ValueNotifier<Uri> implements Uri {
  UriNotifier(super.initial);
  void refresh() => notifyListeners();

  R _updateOnAction<R>(R Function() action) {
    final result = action();
    refresh();
    return result;
  }  @override
  String get scheme => value.scheme;  @override
  String get authority => value.authority;

@override
  String get userInfo => value.userInfo;
  @override
  String get host => value.host;

@override
  int get port => value.port;@override
  String get path => value.path;@override
  String get query => value.query;

@override
  String get fragment => value.fragment;
  @override
  List<String> get pathSegments => value.pathSegments;  @override
  Map<String, String> get queryParameters => value.queryParameters;
  @override
  Map<String, List<String>> get queryParametersAll => value.queryParametersAll;

@override
  bool get isAbsolute => value.isAbsolute;
@override
  bool get hasScheme => value.hasScheme;
@override
  bool get hasAuthority => value.hasAuthority;@override
  bool get hasPort => value.hasPort;
@override
  bool get hasQuery => value.hasQuery;
@override
  bool get hasFragment => value.hasFragment;
@override
  bool get hasEmptyPath => value.hasEmptyPath;
@override
  bool get hasAbsolutePath => value.hasAbsolutePath;@override
  String get origin => value.origin;  @override
  bool isScheme(String scheme) => value.isScheme(scheme);

@override
  String toFilePath({bool? windows}) => value.toFilePath(windows: windows);@override
  UriData? get data => value.data;  @override
  Uri replace({
    String? scheme,
    String? userInfo,
    String? host,
    int? port,
    String? path,
    Iterable<String>? pathSegments,
    String? query,
    Map<String, dynamic /*String?|Iterable<String>*/ >? queryParameters,
    String? fragment,
    bool refresh = true,
  }) =>
      _updateOnAction(() => value.replace(
            scheme: scheme,
            userInfo: userInfo,
            host: host,
            port: port,
            path: path,
            pathSegments: pathSegments,
            query: query,
            queryParameters: queryParameters,
            fragment: fragment,
          ));
  @override
  Uri removeFragment() => _updateOnAction(() => value.removeFragment());@override
  Uri resolve(String reference) =>
      _updateOnAction(() => value.resolve(reference));

  @override
  Uri resolveUri(Uri reference) =>
      _updateOnAction(() => value.resolveUri(reference));

  @override
  Uri normalizePath() => _updateOnAction(() => value.normalizePath());
}
```
lib/src/value_notifier/notifier_classes/int_notifier.dart
```dart
import 'package:flutter/material.dart';

class IntNotifier extends ValueNotifier<int> {
  IntNotifier(super.initial);
}
extension FHUIntValueNotifierExtension on ValueNotifier<int> {
int operator &(int other) => value & other;  int operator |(int other) => value | other;  int operator ^(int other) => value ^ other;  int operator ~() => ~value;int operator <<(int shiftAmount) => value << shiftAmount;int operator >>(int shiftAmount) => value >> shiftAmount;

int operator >>>(int shiftAmount) => value >>> shiftAmount;

int modPow(int exponent, int modulus) => value.modPow(exponent, modulus);  int modInverse(int modulus) => value.modInverse(modulus);
int gcd(int other) => value.gcd(other);
bool get isEven => value.isEven;
bool get isOdd => value.isOdd;
int get bitLength => value.bitLength;

  int toUnsigned(int width) => value.toUnsigned(width);
int toSigned(int width) => value.toSigned(width);

int operator -() => -value;  int abs() => value.abs();

int get sign => value.sign;
double roundToDouble() => value.roundToDouble();
double floorToDouble() => value.floorToDouble();
double ceilToDouble() => value.ceilToDouble();
double truncateToDouble() => value.truncateToDouble();
  String toRadixString(int radix) => value.toRadixString(radix);
}
```
lib/src/value_notifier/notifier_classes/double_notifier.dart
```dart
import 'package:flutter/material.dart';

class DoubleNotifier extends ValueNotifier<double> {
  DoubleNotifier(super.initial);
  @override
  String toString() => value.toStringAsFixed(2);
}
extension FHUDoubleValueNotifierExtension on ValueNotifier<double> {
double remainder(num other) => value.remainder(other);
double operator +(num other) => value + other;
double operator -(num other) => value - other;
double operator *(num other) => value * other;
double operator %(num other) => value % other;
double operator /(num other) => value / other;
int operator ~/(num other) => value ~/ other;
double operator -() => -value;
double abs() => value.abs();  double get sign => value.sign;  int round() => value.round();  int floor() => value.floor();  int ceil() => value.ceil();int truncate() => value.truncate();
  double roundToDouble() => value.roundToDouble();double floorToDouble() => value.floorToDouble();double ceilToDouble() => value.ceilToDouble();
  double truncateToDouble() => value.truncateToDouble();
}
```
lib/src/value_notifier/notifier_classes/date_notifier.dart
```dart
import 'package:flutter/material.dart';class DateTimeNotifier extends ValueNotifier<DateTime> implements DateTime {
  DateTimeNotifier(super.initial);

  bool isEqual(Object other) => value == other;
DateTime updateToNow() => value = DateTime.now();
  @override
  bool isBefore(DateTime other) => value.isBefore(other);
  @override
  bool isAfter(DateTime other) => value.isAfter(other);
  @override
  bool isAtSameMomentAs(DateTime other) => value.isAtSameMomentAs(other);
@override
  int compareTo(DateTime other) => value.compareTo(other);
@override
  DateTime toLocal() => value.toLocal();
@override
  DateTime toUtc() => value.toUtc();@override
  String toIso8601String() => value.toIso8601String();

  @override
  DateTime add(Duration duration) => value.add(duration);

  @override
  DateTime subtract(Duration duration) => value.subtract(duration);
@override
  Duration difference(DateTime other) => value.difference(other);
  @override
  int get millisecondsSinceEpoch => value.millisecondsSinceEpoch;
  @override
  int get microsecondsSinceEpoch => value.microsecondsSinceEpoch;
  @override
  String get timeZoneName => value.timeZoneName;
  @override
  Duration get timeZoneOffset => value.timeZoneOffset;@override
  int get year => value.year;
  @override
  int get month => value.month;@override
  int get day => value.day;@override
  int get hour => value.hour;@override
  int get minute => value.minute;@override
  int get second => value.second;@override
  int get millisecond => value.millisecond;@override
  int get microsecond => value.microsecond;
  @override
  int get weekday => value.weekday;
@override
  bool get isUtc => value.isUtc;
  @override
  String toString() => value.toString();
}
```
